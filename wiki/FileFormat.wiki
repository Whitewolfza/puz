#summary File Format

= Introduction =

PUZ is a file format commonly used by commercial software for crossword puzzles. There is, to our knowledge, no documentation of the format available online.  This page (and the implementations) is the result of a bit of reverse engineering work.

As it currently stands, the documentation is far from complete. However, it is complete enough to read and write basic crossword puzzles in the format, such that you may interoperate with the common crossword applications. I have no real financial interest in this, it was just a fun hack and allows me to produce crossword puzzles for friends to play.

= File Overview =
The file is laid out like this:
  # a fixed-size header with information like the width and height of the puzzle
  # the puzzle solution and the current state of the cells, with size determined by the puzzle dimensions described in the previous section
  # a series of NUL-terminated variable-length strings with information like the author, copyright, and the puzzle clues

== Header Format ==
Define all _short_s to be a little-endian two byte integer.  The file header is then described in the following table.

|| Component || Offset || End || Length || Type || Description ||
|| Checksum || 0x00 || 0x01 || 0x2 || short || overall file checksum ||
|| File Magic || 0x02 || 0x0D || 0xC || string || NUL-terminated constant string: 4143 524f 5353 2644 4f57 4e00 ("ACROSS&DOWN") ||

The following checksums are described in more detail later.
|| Component || Offset || End || Length || Type || Description ||
|| CIB Checksum || 0x0E || 0x0F || 0x2 || short || checksum of the puzzle's CIB ||
|| Masked Low Checksums || 0x10 || 0x13 || 0x4 || || A set of checksums, XOR-masked against a magic string. ||
|| Masked High Checksums || 0x14 || 0x17 || 0x4 || || A set of checksums, XOR-masked against a magic string. ||

|| Component || Offset || End || Length || Type || Description ||
|| Version String(?) || 0x18 || 0x1B || 0x4 || string || e.g. "1.2\0" ||
|| Reserved1C(?) || 0x1C || 0x1D || 0x2 || ? || In many files, this is uninitialized memory ||
|| Unknown || 0x1E || 0x1F || 0x2 || ? || In all files, this is set to 0x0000(?) ||
|| Reserved20(?) || 0x20 || 0x2B || 0xB || ? || In files where Reserved1C is garbage, this is garbage too. ||

The BIC (Board Initialization Checksum) region covers some of the following entries.  These contain the vitals of the puzzle, and are used to initialize the overall checksum of the file.

|| Component || Offset || End || Length || Type || Description ||
|| Width || 0x2C || 0x2C || 0x1 || byte || The width of the board ||
|| Height || 0x2D || 0x2D || 0x1 || byte || The height of the board ||
|| # of Clues || 0x2E || 0x2F || 0x2 || short || The number of clues for this board ||
|| Unknown Bitmask || 0x30 || 0x31 || 0x2 || short || A bitmask. Operations unknown. ||
|| Unknown32 || 0x32 || 0x33 || 0x2 || ? || Unknown short or two bytes... ||

== Puzzle Layout and State ==
Next come the board solution and player state.  (If a player works on a puzzle and then saves their game, the cells they've filled are stored in the state.  Otherwise the state is all blank cells and contains a subset of the information in the solution.)

Boards are stored as a single string of ASCII, with one character per cell of the board beginning at the top-left and scanning in reading order, left to right then top to bottom.  We'll use this board as a running example (where # represents a black cell, and the letters are the filled-in solution).
{{{
C A T
# # A
# # R
}}}

At the end of the header (offset 0x34) comes the solution to the puzzle.  Non-playable (ie: black) cells are denoted by '.'.  So for this example, the board is stored as nine bytes: "CAT..A..R".

Next comes the player state, stored similarly.  Empty cells are stored as '-', so the example board before any cells had been filled in is stored as: "---..#..#".

== Strings Section ==
Immediately following the boards comes the strings.  All strings are encoded in ISO-8859-1 and end with a NUL.  Even if a string is empty, its trailing NUL still appears in the file.  In order, the strings are:

|| Description || Example ||
|| Title || Theme: .PUZ format ||
|| Author || J. Puz / W. Shortz ||
|| Copyright || (c) 2007 J. Puz ||
|| Clue#1 || Cued, in pool ||
|| ... || [more clues] ||
|| Clue#n || Quiet ||
|| Notes || http://mywebsite ||

These first three example strings would appear in the file as:
  "Theme: .PUZ format\0J. Puz / W. Shortz\0(c) 2007 J. Puz\0"

The "Across" clues come before the "Down" clues.

== Clue Assignment ==
Nowhere in the file does it specify which cells get numbers or which clues correspond to which numbers.  These are instead derived from the shape of the puzzle.

Here's a sketch of one way to assign numbers and clues to cells.  First, some helper functions:
{{{
# Returns true if the cell at (x, y) gets an "across" clue number.
def cell_needs_across_number(x, y):
  # Check that there is no blank to the left of us
  if x == 0 or is_black_cell(x-1, y):
    # Check that there is space (at least two cells) for a word here
    if x+1 < width and is_black_cell(x+1):
      return True 
  return False

def cell_needs_down_number(x, y):
  # ...as above, but on the y axis
}}}

And then the actual assignment code:
{{{
# An array mapping across clues to the "clue number".
# So across_numbers[2] = 7 means that the 3rd across clue number
# points at cell number 7.
across_numbers = []

cur_cell_number = 1

# Iterate through th 
for y in 0..height:
  for x in 0..width:
    if is_black_cell(x, y):
      continue

    assigned_number = False
    if cell_needs_across_number(x, y):
      across_numbers.append(cur_cell_number)
      cell_numbers[x][y] = cell_number
      assigned_number = True
    if cell_needs_down_number(x, y):
      # ...as above, with "down" instead
    if assigned_number:    
      cell_number += 1
}}}

With the above computation completed, you can then compute how many across clues and down clues must be in the file.